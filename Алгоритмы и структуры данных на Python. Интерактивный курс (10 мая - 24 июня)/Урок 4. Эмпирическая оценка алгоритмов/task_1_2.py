'''
1. Проанализировать скорость и сложность одного любого алгоритма из разработанных в рамках домашнего задания первых
трех уроков.
Примечание. Идеальным решением будет:
a. выбрать хорошую задачу, которую имеет смысл оценивать,
b. написать 3 варианта кода (один у вас уже есть),
c. проанализировать 3 варианта и выбрать оптимальный,
d. результаты анализа вставить в виде комментариев в файл с кодом (не забудьте указать, для каких N вы проводили замеры),
e. написать общий вывод: какой из трёх вариантов лучше и почему.
    Найти сумму n элементов следующего ряда чисел: 1, -0.5, 0.25, -0.125,…
Количество элементов (n) вводится с клавиатуры.
'''

'''
Этот вариант оказался самым быстрым, т.к. деление и суммирование происходило сразу в цикле без создания списков и 
лишних итераций! За счет этого превосзодит по скорости выполнения.
Сложность алгоритма O(N)
'''

# суммирование сразу в цикле
import cProfile


def count():
    m = 1
    a = 0
    n = 10000000
    for i in range(n):
        m /= -2
        a += m
    return a


#cProfile.run('count()')
# 4 function calls in 0.691 seconds
# 1    0.000    0.000    0.666    0.666 <string>:1(<module>)
#         1    0.666    0.666    0.666    0.666 task_2.py:9(count)
#         1    0.000    0.000    0.666    0.666 {built-in method builtins.exec}

# python3 -m timeit -n 10 -s "import task_1_2" "task_1_2.count()"
# 10 loops, best of 5: 556 msec per loop
